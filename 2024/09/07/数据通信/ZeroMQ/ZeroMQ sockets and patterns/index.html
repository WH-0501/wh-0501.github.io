<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Socket API 将套接字添加到网络拓扑结构中 发送&#x2F;接收消息 Unicast Transports ZeroMQ 不只是数据传输 I&#x2F;O Threads   消息模式 High-Level 消息模式 消息的使用 处理多个套接字 Multipart Messages Intermediaries and Proxies 发现服务问题 Shared Queue Zer">
<meta property="og:type" content="article">
<meta property="og:title" content="ZeroMQ sockets and patterns">
<meta property="og:url" content="http://example.com/2024/09/07/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/ZeroMQ%20sockets%20and%20patterns/index.html">
<meta property="og:site_name" content="Daemo">
<meta property="og:description" content="Socket API 将套接字添加到网络拓扑结构中 发送&#x2F;接收消息 Unicast Transports ZeroMQ 不只是数据传输 I&#x2F;O Threads   消息模式 High-Level 消息模式 消息的使用 处理多个套接字 Multipart Messages Intermediaries and Proxies 发现服务问题 Shared Queue Zer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/HTTP%20%E4%B8%8E%20ZeroMQ.png">
<meta property="og:image" content="http://example.com/images/request-reply%20broker.png">
<meta property="og:image" content="http://example.com/images/pub-sub%20forwarder%20proxy.png">
<meta property="og:image" content="http://example.com/images/multithreaded%20server.png">
<meta property="og:image" content="http://example.com/images/pub-sub%20envelop.png">
<meta property="og:image" content="http://example.com/images/pub-sub%20envelop%20with%20sender%20address.png">
<meta property="article:published_time" content="2024-09-07T12:37:29.000Z">
<meta property="article:modified_time" content="2024-09-22T06:42:30.691Z">
<meta property="article:author" content="Damon">
<meta property="article:tag" content="ZeroMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/HTTP%20%E4%B8%8E%20ZeroMQ.png">


<link rel="canonical" href="http://example.com/2024/09/07/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/ZeroMQ%20sockets%20and%20patterns/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/09/07/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/ZeroMQ%20sockets%20and%20patterns/","path":"2024/09/07/数据通信/ZeroMQ/ZeroMQ sockets and patterns/","title":"ZeroMQ sockets and patterns"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZeroMQ sockets and patterns | Daemo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Daemo</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">内诚于心，外信于人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket-API"><span class="nav-number">2.</span> <span class="nav-text">Socket API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%A5%97%E6%8E%A5%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E4%B8%AD"><span class="nav-number">2.1.</span> <span class="nav-text">将套接字添加到网络拓扑结构中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-number">2.2.</span> <span class="nav-text">发送&#x2F;接收消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicast-Transports"><span class="nav-number">2.3.</span> <span class="nav-text">Unicast Transports</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZeroMQ-%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">2.4.</span> <span class="nav-text">ZeroMQ 不只是数据传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-Threads"><span class="nav-number">2.5.</span> <span class="nav-text">I&#x2F;O Threads</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">消息模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#High-Level-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">High-Level 消息模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">消息的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">3.3.</span> <span class="nav-text">处理多个套接字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multipart-Messages"><span class="nav-number">3.4.</span> <span class="nav-text">Multipart Messages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intermediaries-and-Proxies"><span class="nav-number">3.5.</span> <span class="nav-text">Intermediaries and Proxies</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.</span> <span class="nav-text">发现服务问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shared-Queue"><span class="nav-number">3.7.</span> <span class="nav-text">Shared Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZeroMQ-%E7%9A%84%E5%86%85%E7%BD%AE%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.</span> <span class="nav-text">ZeroMQ 的内置代理函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transport-Bridging"><span class="nav-number">3.9.</span> <span class="nav-text">Transport Bridging</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E5%8F%8A-ETERM"><span class="nav-number">4.</span> <span class="nav-text">处理错误及 ETERM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.</span> <span class="nav-text">处理中断信号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">检查内存泄漏</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Damon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/07/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/ZeroMQ%20sockets%20and%20patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Damon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Daemo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ZeroMQ sockets and patterns | Daemo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ZeroMQ sockets and patterns
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-07 20:37:29" itemprop="dateCreated datePublished" datetime="2024-09-07T20:37:29+08:00">2024-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-22 14:42:30" itemprop="dateModified" datetime="2024-09-22T14:42:30+08:00">2024-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">数据通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/" itemprop="url" rel="index"><span itemprop="name">ZeroMQ</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id=""><a href="#" class="headerlink" title=""></a></h1><!-- TOC -->

<ul>
<li><a href="#"></a></li>
<li><a href="#socket-api">Socket API</a><ul>
<li><a href="#%E5%B0%86%E5%A5%97%E6%8E%A5%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E4%B8%AD">将套接字添加到网络拓扑结构中</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF">发送&#x2F;接收消息</a></li>
<li><a href="#unicast-transports">Unicast Transports</a></li>
<li><a href="#zeromq-%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93">ZeroMQ 不只是数据传输</a></li>
<li><a href="#io-threads">I&#x2F;O Threads</a></li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F">消息模式</a><ul>
<li><a href="#high-level-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F">High-Level 消息模式</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8">消息的使用</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%A5%97%E6%8E%A5%E5%AD%97">处理多个套接字</a></li>
<li><a href="#multipart-messages">Multipart Messages</a></li>
<li><a href="#intermediaries-and-proxies">Intermediaries and Proxies</a></li>
<li><a href="#%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98">发现服务问题</a></li>
<li><a href="#shared-queue">Shared Queue</a></li>
<li><a href="#zeromq-%E7%9A%84%E5%86%85%E7%BD%AE%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0">ZeroMQ 的内置代理函数</a></li>
<li><a href="#transport-bridging">Transport Bridging</a></li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E5%8F%8A-eterm">处理错误及 ETERM</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7">处理中断信号</a></li>
<li><a href="#%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">检查内存泄漏</a></li>
<li><a href="#zeromq-%E5%A4%9A%E7%BA%BF%E7%A8%8B">ZeroMQ 多线程</a></li>
<li><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E2%80%BB">零拷贝※</a></li>
<li><a href="#pub-sub-message-envelopes">Pub-Sub Message Envelopes</a></li>
<li><a href="#high-water-marks%E5%8D%B3-hwm">High-Water Marks即 HWM</a></li>
</ul>
<!-- /TOC -->

<h1 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h1><p>ZMQ 提供了一套类似于 BSD 套接字的 API，但将很多消息处理机制的细节隐藏了起来。  </p>
<p>套接字事实上是用于网络编程的标准接口，ZMQ 之所那么吸引人眼球（stopping your eyes from falling onto your cheeks），原因之一就是它是建立在标准套接字 API 之上。因此，ZMQ 的套接字操作非常容易理解，其生命周期主要包含四个部分：  </p>
<ul>
<li>创建和销毁套接字：<code>zmq_socket()</code>, <code>zmq_close()</code></li>
<li>配置和读取套接字选项：<code>zmq_setsockopt()</code>， <code>zmq_getsockopt()</code></li>
<li>为套接字建立连接：<code>zmq_bind()</code>，<code>zmq_connect()</code>  </li>
<li>发送和接收消息：<code>zmq_send()</code>，<code>zmq_recv()</code></li>
</ul>
<p>注意：套接字永远是 void * 类型，而消息则是一个数据结构体。因此，在 C 语言中，通过变量传递套接字，而用引用传递消息。注意：<strong>ZMQ 中所有的套接字都由 ZMQ 管理，只有消息是由用户管理</strong>。  </p>
<p>创建、销毁以及配置套接字的工作和处理任何对象一样。但是，注意 ZMQ 是异步的、可扩展的，因此将其应用到网络结构中时，可能需要更多时间来理解。  </p>
<h2 id="将套接字添加到网络拓扑结构中"><a href="#将套接字添加到网络拓扑结构中" class="headerlink" title="将套接字添加到网络拓扑结构中"></a>将套接字添加到网络拓扑结构中</h2><p>连接两个节点时，其中一个节点需要适用 <code>zmq_bind()</code>，另一个则使用 <code>zmq_connect()</code>。通常而言，使用 <code>zmq_bind()</code> 的节点称为服务器，其有一个较为固定的网络地址；使用 <code>zmq_connect()</code> 连接的节点称为客户端，其地址不固定。  </p>
<p>ZMQ 连接和传统 TCP 连接的区别主要有：  </p>
<ul>
<li>使用多种协议，例如：inproc(进程内)、IPC(进程间)、TCP、pgm、epgm 等。对应接口：<code>zmq_inproc()</code>、<code>zmq_ipc()</code>、<code>zmq_tcp()</code>、<code>zmq_pgm()</code>、<code>zmq_epgm()</code> 等</li>
<li>一个套接字可以有许多 outgoing 连接和许多 incoming 连接</li>
<li>没有 <code>zmq_accept()</code> 方法。当套接字绑定到端点时，它会自动开始 accepting 连接</li>
<li>网络连接是在后台进行的，如果网络连接断开(例如，如果端点退出然后又重启)，ZeroMQ 会自动重新连接</li>
<li>应用程序代码不能直接使用这些连接；它们被封装在 ZMQ 底层</li>
<li>连接是异步的，并由一组消息队列做缓冲</li>
<li>连接会表现出某种消息模式，这是由创建连接的套接字类型决定的</li>
</ul>
<p>很多架构中都使用 C&#x2F;S 架构。其中服务端是比较稳定的组件，而客户端组件则较为动态，也就是说，它们经常启动&#x2F;停止。所以，有时会出现寻址问题：服务器对客户端是可见的，但客户端不一定是可见的。因此，架构中哪些组件应作为服务端(使用 <code>zmq_bind()</code>)，哪些作为客户端(<code>zmq_connect()</code>) 是很明显的。同时，它还取决于正在使用的套接字类型，对于不同的网络体系结构有一些例外。  </p>
<p>在传统网络连接中，先打开客户端时一定会收到系统报错信息，但 ZQM 让用户能够自由地启动架构中的组件。当客户端使用 <code>zmq_connect()</code> 连接至某个端点时，它就已经能够使用该套接字发送消息了。如果这时，服务端启动起来了，并使用 <code>zmq_bind()</code> 绑定至该端点，ZMQ 将自动开始转发消息。  </p>
<p>服务端节点可以仅使用一个套接字就能绑定至多个端点，也就是说，能够使用不同的协议来建立连接。例如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zmq_bind (socket, <span class="string">&quot;tcp://*:5555&quot;</span>);</span><br><span class="line">zmq_bind (socket, <span class="string">&quot;tcp://*:9999&quot;</span>);</span><br><span class="line">zmq_bind (socket, <span class="string">&quot;ipc://myserver.ipc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意：不能多次绑定至同一个端点。  </p>
<p>每当有客户端节点使用 <code>zmq_connect()</code> 连接至上述某个端点时，服务端就会自动创建连接。ZMQ 没有对连接数量进行限制。此外，<strong>客户端节点也可以使用一个套接字同时建立多个连接</strong>。  </p>
<p><strong>套接字是有类型的，套接字类型定义了套接字的行为，它在发送和接收消息时的规则等</strong>。<strong>可以将不同种类的套接字进行连接</strong>，如 PUB-SUB 组合，这种组合称之为发布-订阅模式，其他组合也会有相应的模式名称。  </p>
<h2 id="发送-接收消息"><a href="#发送-接收消息" class="headerlink" title="发送&#x2F;接收消息"></a>发送&#x2F;接收消息</h2><p>发送和接收消息使用的是 <code>zmq_msg_send()</code>和 <code>zmq_msg_recv()</code>。虽然函数名称看起来很直白，但由于 ZMQ 的 I&#x2F;O 模式和传统的TCP协议有很大不同，因此还是需要花点时间去理解的。  </p>
<p>TCP 套接字和 ZMQ 套接字在传输数据方面的区别：  </p>
<ul>
<li>**ZMQ 套接字传输的是消息，而不是字节(TCP)或帧(UDP)**。消息是指一段指定长度的二进制数据。这种设计是为了性能优化而考虑的</li>
<li>ZMQ 套接字在后台进行 I&#x2F;O 操作，即：无论是接收还是发送消息，都会先传送到一个本地的缓冲队列，这个内存队列的大小是可配置的</li>
<li>根据套接字类型，ZMQ 套接字内置一对多路由行为；此外。ZMQ 还支持多对多、多对一、一对一连接。TCP 只能进行点对点的连接</li>
</ul>
<p><code>zmq_send()</code> 方法实际上并不会将消息发送到套接字连接。消息会在一个内存队列中保存下来，以便 I&#x2F;O 线程可以<strong>异步</strong>发送消息。它不会阻塞，除非在某些例外情况下。因此，当 <code>zmq_send()</code> 返回时，并不一定已发送消息。  </p>
<blockquote>
<hr>
<ul>
<li>当用 <code>zmq_msg_init_data()</code> 初始化消息后，不能重用或是释放这条消息，否则 ZMQ 的 I&#x2F;O 线程会认为它在传输垃圾数据</li>
</ul>
<hr>
</blockquote>
<p>  

<h2 id="Unicast-Transports"><a href="#Unicast-Transports" class="headerlink" title="Unicast Transports"></a>Unicast Transports</h2><p>ZMQ 提供了一组单播传输协议(inproc、IPC、TCP)，以及两个广播协议(epgm、pgm)。  </p>
<p><em><strong>fan-out ratios will make 1-to-N unicast impossible</strong></em>  </p>
<p>通常会使用 TCP 作为传输协议，ZMQ 中的 TCP 连接是可以脱机运作的，其灵活、便携、且足够快速。之所以称之为**脱机(disconnected)**，是因为 ZMQ 中 TCP 连接不需要该端点已经有某个服务器进行了绑定，客户端和服务端可以随时进行连接和绑定，这对应用程序而言都是透明的。  </p>
<p>ZMQ 中的进程间通信协议 IPC 类似 TCP，也是脱机的。它有一个限制：<strong>不能在Windows上运行</strong>。按照惯例，使用带有 <code>.ipc</code> 后缀的端点名，以避免与其他文件名的潜在冲突。在 UNIX 系统上，使用 ipc 端点时，需要注意权限问题，否则它们可能无法在以不同用户 id 运行的进程之间共享。还必须确保所有进程都可以访问这些 IPC 端点文件。  </p>
<p>线程内通信协议 inproc，可以在同一个进程的不同线程之间进行消息传输，比 IPC 或 TCP 快得多。该协议有一个限制：<strong>必须先绑定到端点，才能建立连接</strong>。该限制将在 ZeroMQ v4.0 后之后的版本修复。  </p>
<h2 id="ZeroMQ-不只是数据传输"><a href="#ZeroMQ-不只是数据传输" class="headerlink" title="ZeroMQ 不只是数据传输"></a>ZeroMQ 不只是数据传输</h2><p><strong>ZeroMQ is Not a Neutral Carrier</strong>  </p>
<p>ZeroMQ 不是一个中立的载体：<strong>它在它使用的传输协议上强加了一个帧。这种帧与现有协议不兼容</strong>，现有协议倾向于使用自己的帧。例如，比较 HTTP 请求和 ZeroMQ 请求，两者都通过TCP&#x2F;IP。 </p>
<p><img src="/./images/HTTP%20%E4%B8%8E%20ZeroMQ.png" alt="HTTP vs ZeroMQ">    </p>
<p>HTTP request 使用 CR-LF 作为最简单的帧分隔符，而 ZeroMQ 使用长度指定的帧。虽然可以使用 ZeroMQ 编写一个类似 HTTP 协议的东西，但这并不是 HTTP。  </p>
<p>从v3.3开始，ZeroMQ 有一个名为 <strong><code>ZMQ_ROUTER_RAW</code></strong> 的套接字选项，它允许在没有 ZeroMQ 帧的情况下读写数据。可以使用它来读取和编写正确的 HTTP 请求和响应。Hardeep Singh 贡献了这个更改，这样他就可以从他的 ZeroMQ 应用程序连接到 Telnet 服务器。在撰写本文时，这仍然是实验性的，但它显示了 ZeroMQ 如何不断发展以解决新问题。  </p>
<p>可以使用 ZeroMQ 设计自有通信协议。参考：<a target="_blank" rel="noopener" href="http://mongrel2.org/">Mongrel2</a> 网络服务架构。  </p>
<h2 id="I-O-Threads"><a href="#I-O-Threads" class="headerlink" title="I&#x2F;O Threads"></a>I&#x2F;O Threads</h2><p>前面提到 ZeroMQ 是通过后台 I&#x2F;O 线程进行消息传输的。除了最极端的应用程序外，一个 I&#x2F;O 线程已经足以处理多个套接字的数据传输要求。这也是创建 context 时传入的 1 的作用：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *context = <span class="built_in">zmq_init</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>创建多个 I&#x2F;O 线程：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> io_threads = <span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> *context = <span class="built_in">zmq_ctx_new</span> ();</span><br><span class="line"><span class="built_in">zmq_ctx_set</span> (context, ZMQ_IO_THREADS, io_threads);</span><br><span class="line"><span class="built_in">assert</span> (<span class="built_in">zmq_ctx_get</span> (context, ZMQ_IO_THREADS) == io_threads);</span><br></pre></td></tr></table></figure>

<p>已经看到，ZeroMQ 中一个套接字可以同时处理数十甚至数千个连接。这对如何编写应用程序具有根本性的影响。<strong>传统的网络应用程序每个远程连接有一个进程或一个线程，每个进程或线程处理一个套接字</strong>。ZeroMQ 允许将整个结构折叠为单个进程，然后根据扩展需要将其分解。</p>
<p>如果仅将 ZeroMQ 用于线程间通信(即，不进行外部套接字 I&#x2F;O 的多线程应用程序)，则可以将 I&#x2F;O 线程设置为零。这并不是一个重要的优化，更多的是一种好奇。  </p>
<h1 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h1><p>ZeroMQ 套接字 API 中提供了多种消息模式。  </p>
<ul>
<li>ZeroMQ 会将消息快速高效地发送给其它节点。这里的节点可以是线程、进程或其它 nodes；</li>
<li>ZeroMQ 为应用程序提供了一套简单的套接字 API，不需要考虑实际使用的协议类型(in-process、inter-process、TCP、multicast)；</li>
<li>ZeroMQ 会自动进行连接或重连；</li>
<li>无论是发送消息还是接收消息，ZeroMQ 都会先将消息放入队列中，并保证进程不会因为内存溢出而崩溃；</li>
<li>ZeroMQ 会处理套接字异常；</li>
<li>所有 I&#x2F;O 操作都在后台进行；</li>
<li><strong>ZeroMQ 使用无锁技术在节点之间通信</strong>，因此不存在锁、等待、信号量或死锁，不会产生死锁</li>
</ul>
<p>但是，以上种种的前提是用户能够正确地使用消息模式。  </p>
<p>ZeroMQ 消息模式是指不同类型套接字的组合。换句话说，要理解 ZeroMQ 的消息模式，需要了解套接字类型以及它们如何协同工作。  </p>
<p>ZeroMQ 内置的核心消息模式包括：  </p>
<ul>
<li><strong>Request-reply</strong>：该模式将一组服务端和一组客户端相连，用于远程过程调用会任务分发</li>
<li><strong>Pub-sub</strong>：该模式将一组发布者和一组订阅者相连，用于数据分发</li>
<li><strong>Pipeline</strong>：该模式以扇出&#x2F;扇入形式连接节点，该模式可以有多个步骤和循环。这是一个并行的任务分发和收集模式</li>
<li><strong>Exclusive pair</strong>：该模式将两个套接字一对一的连接起来。这是一种在进程中连接两个线程的模式，不要与“普通”套接字对混淆</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://api.zeromq.org/master:zmq_socket"><code>zmq_socket()</code></a>手册中详细介绍了所有消息模式。  </p>
<p>以下是合法的套接字连接-绑定对（一端绑定，一端连接即可）：  </p>
<ul>
<li>PUB and SUB</li>
<li>REQ and REP</li>
<li>REQ and ROUTER (take care, REQ inserts an extra null frame)</li>
<li>DEALER and REP (take care, REP assumes a null frame)</li>
<li>DEALER and ROUTER</li>
<li>DEALER and DEALER</li>
<li>ROUTER and ROUTER</li>
<li>PUSH and PULL</li>
<li>PAIR and PAIR</li>
</ul>
<p>还将看到对 XPUB 和 XSUB 套接字的引用。任何其他组合都将产生未记录且不可靠的结果，并且如果尝试它们，ZeroMQ 的未来版本可能会返回错误。当然，可以并且将通过代码桥接其他套接字类型，即从一个套接字类型读取并写入另一个套接字类型。  </p>
<h2 id="High-Level-消息模式"><a href="#High-Level-消息模式" class="headerlink" title="High-Level 消息模式"></a>High-Level 消息模式</h2><p>上面四种核心模式是 ZeroMQ 中内置的，是 API 的一部分，在 ZeroMQ 的 C++ 核心类库中实现，能保证正确运行。  </p>
<p>在这些核心消息模式之上，会建立更为上层的消息模式。这种模式可以用任何预研编写，不属于核心模式，也不会随 ZeroMQ 发布。  </p>
<h2 id="消息的使用"><a href="#消息的使用" class="headerlink" title="消息的使用"></a>消息的使用</h2><p>ZeroMQ 的传输单位是消息，是一个二进制块。可以使用任意序列化工具，如 protocol buffer、XDR 等，将内容转换为 ZeroMQ 消息。  </p>
<p><code>libzmq</code> 核心库实际上有两个 API 来发送和接收消息。前面已经看到和使用的 <code>zmq_send()</code> 和 <code>zmq_recv()</code> 方法是简单的一行程序。后续会经常使用这两个接口，但 <code>zmq_recv()</code> 不擅长处理任意大小的消息：它将消息截断为提供的缓冲区大小。所以有第二个 API 与 zmq_msg_t 结构一起工作，具有更丰富但更复杂的 API:  </p>
<ul>
<li>初始化消息：<code>zmq_msg_init()</code>、<code>zmq_msg_init_size()</code>、<code>zmq_msg_init_data()</code></li>
<li>发送及接收消息：<code>zmq_msg_send()</code>、<code>zmq_msg_recv()</code></li>
<li>释放消息：<code>zmq_msg_close()</code></li>
<li>访问消息内容：<code>zmq_msg_data()</code>、<code>zmq_msg_size()</code>、<code>zmq_msg_more()</code></li>
<li>操作消息属性：<code>zmq_msg_get()</code>、<code>zmq_msg_set()</code>  </li>
<li>消息处理：<code>zmq_msg_copy()</code>、<code>zmq_msg_move()</code></li>
</ul>
<p>在内存中，ZeroMQ 消息用 <code>zmq_msg_t</code> 结构表示。在 C 语言中使用 ZeroMQ 消息的基本规则:  </p>
<ul>
<li>创建并传递 <code>zmq_msg_t</code> 对象，而不是一组数据块</li>
<li>读取消息是，先用 <code>zmq_msg_init()</code> 初始化一个空消息，然后将其传递给 <code>zmq_recv()</code> 函数</li>
<li>写入消息时，先用 <code>zmq_msg_init_size()</code> 来创建消息(同时也初始化了一块内存区域)，然后使用 <code>memcpy()</code> 函数将数据拷贝到该对象中，最后传递给 <code>zmq_send()</code>  </li>
<li>释放消息（并不是销毁）时，使用 <code>zmq_msg_close()</code> 函数，它会将对消息对象的引用删除，最终由 ZeroMQ 将消息销毁</li>
<li>获取消息内容时需使用 <code>zmq_msg_data()</code> 函数；若想知道消息的长度，可以使用 <code>zmq_msg_size()</code> 函数</li>
</ul>
<p>如果需要多次发送相同的消息，并且该消息相当大，请创建第二条消息，使用 <code>zmq_msg_init()</code> 对其进行初始化，然后使用 <code>zmq_msg_copy()</code> 创建第一条消息的副本。这不是复制数据，而是复制引用。然后，可以发送消息两次，并且只有在发送或关闭最后一个副本时才会最终销毁消息。  </p>
<p>帧是 ZeroMQ 消息的基本连线格式。帧是指定长度的数据块。长度可以是 0 以上。有一个称为 <a target="_blank" rel="noopener" href="http://rfc.zeromq.org/spec:15">ZMTP</a> 的线级协议，它定义了 ZeroMQ 如何在 TCP 连接上读写帧。  </p>
<p>关于消息，还有一些需要注意的地方：  </p>
<ul>
<li>可以发送长度为 0  的消息，例如：从一个线程向另一个线程发送信号</li>
<li>ZeroMQ 的消息作为一个整体来收发的，不会只收到消息的一部分  </li>
<li>ZeroMQ 不会立即发送消息，而是有一定延迟（非实时？？）</li>
<li>消息必须能在内存中保存，若想发送文件或大的消息，则需将其切割成小块，在独立的消息中进行发送  </li>
<li>必须使用 <code>zmq_msg_close()</code> 函数来关闭消息，但在一些会在变量超出作用域时自动释放消息对象的语言中除外</li>
</ul>
<p>注意：不要贸然使用 <code>zmq_msg_init_data()</code>，它是用于零拷贝，且可能会造成麻烦。  </p>
<h2 id="处理多个套接字"><a href="#处理多个套接字" class="headerlink" title="处理多个套接字"></a>处理多个套接字</h2><p>要从多个端点读取消息，最简单的方法是将一个套接字连接到所有端点上，让 ZeroMQ 执行 <em><strong>fan-in</strong></em>。如果远程端点处于相同的模式，这是合法的，但是<strong>将 PULL 套接字连接到 PUB 端点将是错误的</strong>。</p>
<p>正确的方法是使用 <code>zmq_poll()</code>。更好的方法是将 <code>zmq_poll()</code> 封装为一个框架，编写一个事件驱动反应器(event-driven reactor)。  </p>
<p><code>zmq_poll()</code> 将使用 <code>zmq_pollitem_t</code>:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">void</span> *socket;       <span class="comment">//  ZeroMQ socket to poll on</span></span><br><span class="line">    <span class="type">int</span> fd;             <span class="comment">//  OR, native file handle to poll on</span></span><br><span class="line">    <span class="type">short</span> events;       <span class="comment">//  Events to poll on</span></span><br><span class="line">    <span class="type">short</span> revents;      <span class="comment">//  Events returned after poll</span></span><br><span class="line">&#125; <span class="type">zmq_pollitem_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Multipart-Messages"><a href="#Multipart-Messages" class="headerlink" title="Multipart Messages"></a>Multipart Messages</h2><p>使用 multipart 消息时，每个部分都是一个 <code>zmq_msg</code> 项。例如，如果要发送一个包含五个部分的消息，必须构造、发送和销毁五个 <code>zmq_msg</code> 项。  </p>
<p>下面是如何在一个 multipart 消息中发送帧(将每个帧接收到一个消息对象中):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">zmq_msg_send</span> (&amp;message, socket, ZMQ_SNDMORE);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">zmq_msg_send</span> (&amp;message, socket, ZMQ_SNDMORE);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">zmq_msg_send</span> (&amp;message, socket, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>下面是如何接收和处理消息中的所有部分，无论是单个部分还是多个部分:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">zmq_msg_t</span> message;</span><br><span class="line">    <span class="built_in">zmq_msg_init</span> (&amp;message);</span><br><span class="line">    <span class="built_in">zmq_msg_recv</span> (&amp;message, socket, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//  Process the message frame</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">zmq_msg_close</span> (&amp;message);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">zmq_msg_more</span> (&amp;message))</span><br><span class="line">        <span class="keyword">break</span>;      <span class="comment">//  Last message frame</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 Multipart 消息需要了解的一些事情:  </p>
<ul>
<li>发送 multipart 消息时，第一部分(及后续部分)在发送最后一部分之后才会真正的发送出去</li>
<li>若使用 <code>zmq_poll()</code>，当接收到第一部分消息时，实际上其余的部分也都到达了  </li>
<li>要么就接收到所有消息，要么就完全接收不到，不会接收到不完整的消息  </li>
<li>消息的每个部分都是一个 <code>zmq_msg</code> 项</li>
<li>无论是否选中 more 属性，都将收到消息的所有部分</li>
<li>在发送时，ZeroMQ 将消息帧在内存中排队，直到最后一个消息帧被接收，然后将它们全部发送出去</li>
<li>没有办法取消部分发送的消息，除非关闭套接字</li>
</ul>
<h2 id="Intermediaries-and-Proxies"><a href="#Intermediaries-and-Proxies" class="headerlink" title="Intermediaries and Proxies"></a>Intermediaries and Proxies</h2><h2 id="发现服务问题"><a href="#发现服务问题" class="headerlink" title="发现服务问题"></a>发现服务问题</h2><p>在设计大型分布式架构时，将遇到的一个问题是发现。也就是说，pieces 是如何知道彼此的？如果 pieces 来了又走，这尤其困难，所以称之为“动态发现问题”。  </p>
<p>有几种动态发现的解决方案。最简单的方法是通过硬编码(或配置)网络架构来完全避免这种情况，以便手工完成发现。也就是说，当添加一个新 piece 时，需要重新配置网络以发现它。该方式在客户端增多时，维护的代价越来越大。  </p>
<p>对此有很多答案，但最简单的答案是添加一个中介；也就是说，所有其他节点都连接到网络中的一个静态点。在经典消息传递中，这是消息代理的工作。ZeroMQ 没有自带消息代理，但是它让我们可以很容易地构建中介体。  </p>
<h2 id="Shared-Queue"><a href="#Shared-Queue" class="headerlink" title="Shared Queue"></a>Shared Queue</h2><p>在实际情况中，通常需要允许多个服务和多个客户端。这让我们可以扩展服务的能力(多个线程、进程或节点，而不仅仅是一个)。唯一的约束是<strong>服务必须是无状态的</strong>，所有状态都在请求中或在某些共享存储(如数据库)中。  </p>
<p>有两种方法可以将多个客户机连接到多个服务器。<strong>暴力方法</strong>是将每个客户端套接字连接到多个服务端点。一个客户端套接字可以连接到多个服务套接字，然后 REQ 套接字将在这些服务之间分发请求。假设将客户端套接字连接到三个服务端点；A、B、C。客户端请求R1、R2、R3、R4。R1 和 R4 去服务端 A, R2 去服务端 B, R3 去服务端 C。  </p>
<p>这种设计使得可以方便地添加更多客户端。还可以添加更多的服务端。每个客户机将其请求分发给服务。但是每个客户机都必须知道服务拓扑。如果有 100 个客户端，然后决定再添加三个服务，那么需要重新配置并重新启动 100 个客户端，以便客户端了解这三个新服务。  </p>
<p>因此，将编写一个小消息队列代理来提供这种灵活性。代理绑定到两个端点，一个 frontend 用于客户端，一个 backend 用于服务端。然后，它使用 <code>zmq_poll()</code> 监视这两个套接字的活动，当有活动时，它在两个套接字之间传送消息。它实际上并不显式地管理任何队列 —— ZeroMQ 在每个套接字上自动管理队列。  </p>
<p>当使用 REQ 与 REP 通信时，将得到一个严格同步的请求-应答会话。客户端发送请求。服务读取请求并发送应答。然后客户端读取应答。如果客户端或服务试图做任何其他事情(例如，连续发送两个请求而不等待响应)，它们将得到一个错误。  </p>
<p>但 broker 必须是非阻塞的。显然，可以使用 <code>zmq_poll()</code> 来等待两个套接字上的活动，但是不能使用 REP 和 REQ。    </p>
<p>幸运的是，有两个套接字 <em><code>DEALER</code></em> 和 <em><code>ROUTER</code></em> ，它们允许执行非阻塞请求-响应。<br><img src="/./images/request-reply%20broker.png" alt="request-reply broker.png">  </p>
<p>在这个简单的扩展请求-应答模式中，REQ 与 ROUTER 对话，DEALER 与 REP 对话。在 DEALER 和 ROUTER 之间，必须有代码将消息从一个套接字中取出并推到另一个套接字上。</p>
<h2 id="ZeroMQ-的内置代理函数"><a href="#ZeroMQ-的内置代理函数" class="headerlink" title="ZeroMQ 的内置代理函数"></a>ZeroMQ 的内置代理函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">zmq_proxy</span>(frontend, backend, capture);</span><br></pre></td></tr></table></figure>
<p>两个套接字(或者三个套接字，如果想捕获数据)必须正确连接、绑定和配置。  </p>
<h2 id="Transport-Bridging"><a href="#Transport-Bridging" class="headerlink" title="Transport Bridging"></a>Transport Bridging</h2><p>ZeroMQ用户经常提出的一个问题是，“如何将 ZeroMQ 网络与 X 技术连接起来?”其中 X 是其他网络或消息传递技术。</p>
<p>最简单的答案就是 <em>bridge</em>。Bridge 是一个小应用程序，它在一个套接字上使用一种协议，并在另一个套接字上转换为&#x2F;从另一种协议。可以看做一个协议解释器。ZeroMQ 中常见的桥接问题是桥接两个传输或网络。  </p>
<p><img src="/./images/pub-sub%20forwarder%20proxy.png" alt="pub-sub forwarder proxy"></p>
<h1 id="处理错误及-ETERM"><a href="#处理错误及-ETERM" class="headerlink" title="处理错误及 ETERM"></a>处理错误及 ETERM</h1><p>ZeroMQ 的错误处理理念是<strong>快速崩溃</strong>和弹性的结合。<strong>一个进程对于自身内部的错误来说要越脆弱越好，而对外部的攻击和错误要足够健壮</strong>。  </p>
<p><strong>代码中应该对每一次的 ZMQ 函数调用作错误处理</strong>。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *socket = <span class="built_in">zmq_socket</span> (context, ZMQ_REP);</span><br><span class="line"><span class="built_in">assert</span> (socket);</span><br></pre></td></tr></table></figure>
<p>不要将函数调用直接放在 <code>assert()</code> 函数中，因为一些优化程序会直接将程序中的 <code>assert()</code> 函数去除。  </p>
<h1 id="处理中断信号"><a href="#处理中断信号" class="headerlink" title="处理中断信号"></a>处理中断信号</h1><p>实际的应用程序需要在使用 Ctrl-C 或其他信号(如SIGTERM)时正确地清理和退出。默认情况下，这些信号会终止进程，这意味着尚未发送的消息会就此丢失，文件不会被正确地关闭等等。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_interrupted = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">s_signal_handler</span> <span class="params">(<span class="type">int</span> signal_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_interrupted = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">s_catch_signals</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> action;</span><br><span class="line">    action.sa_handler = s_signal_handler;</span><br><span class="line">    action.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span> (&amp;action.sa_mask);</span><br><span class="line">    <span class="built_in">sigaction</span> (SIGINT, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sigaction</span> (SIGTERM, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">s_catch_signals</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (s_interrpted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当接收到 Ctrl-C(SIGINT) 或 SIGTERM 信号时，会将 <code>s_interrupted</code> 设置为 1。此时程序不会自动停止，而是退出循环，执行清理操作。   </p>
<p>注意：  </p>
<ul>
<li>若程序在 <code>zmq_recv()</code>、<code>zmq_poll()</code>、<code>zmq_send()</code> 等函数中阻塞，当有信号传来时，会返回 <code>EINTR</code></li>
<li>像 <code>s_recv()</code> 函数会将这种中断封装为 NULL 返回</li>
</ul>
<h1 id="检查内存泄漏"><a href="#检查内存泄漏" class="headerlink" title="检查内存泄漏"></a>检查内存泄漏</h1><p>任何长时间运行的程序都应该妥善的管理内存，否则最终会发生内存溢出，导致程序崩溃。使用类似C&#x2F;C++之类的语言时，需要自己动手进行内存管理。  </p>
<p>Linux 下常用内存泄漏检查工具：  </p>
<ul>
<li>valgrind</li>
<li>mtrace：为内存分配函数(<code>malloc</code>,<code>rellaoc</code>,<code>memalign</code>,<code>free</code>)安装 hook 函数</li>
<li>dmalloc：检查程序运行结束还没有释放的内存</li>
<li>memwatch：可检测未释放的内存、多次释放同一段内存、位址存取错误及不当使用未分配的内存区域</li>
<li>mpatrol：</li>
<li>dbgmem：</li>
<li>Electric Fece：不仅能跟踪 <code>malloc()</code> 和 <code>free()</code>，同时还能检测读访问及写入，能够准确指出导致错误的指令</li>
</ul>
<p>要对 ZeroMQ 使用 valgrind，需要注意一下事项：</p>
<ul>
<li>默认情况下，ZeroMQ 会导致 valgrind 不停地输出警告，要剔除警告信息，可创建 vg.supp 文件：  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   &lt;socketcall_sendto&gt;</span><br><span class="line">   Memcheck<span class="punctuation">:</span>Param</span><br><span class="line">   socketcall.sendto(msg)</span><br><span class="line">   fun<span class="punctuation">:</span>send</span><br><span class="line">   ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   &lt;socketcall_sendto&gt;</span><br><span class="line">   Memcheck<span class="punctuation">:</span>Param</span><br><span class="line">   socketcall.send(msg)</span><br><span class="line">   fun<span class="punctuation">:</span>send</span><br><span class="line">   ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<!--在编译时指定 `ZMQ_MAKE_VALGRIND_HAPPY` 宏，否则会不停输出警告。    
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> zeromq2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> CPPFLAGS=-DZMQ_MAKE_VALGRIND_HAPPY</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean; make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> make install</span></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<ul>
<li>应用程序应正确地处理 Ctrl-C，尤其是长时间运行的程序，如果不这么做，valgrind 会报告所有已分配的内存发生了错误</li>
<li>使用 -DDEBUG 编译程序，这样可让 valgrind 告知具体哪段代码发生内存泄漏</li>
</ul>
<p><code>valgrind --tool=memcheck --leak-check=full --suppressions=vg.supp someprog</code>  </p>
<h1 id="ZeroMQ-多线程"><a href="#ZeroMQ-多线程" class="headerlink" title="ZeroMQ 多线程"></a>ZeroMQ 多线程</h1><p><strong>并发编程：不要共享状态</strong>。  </p>
<p>使用 ZeroMQ 编写多线程代码，需遵循以下规则：  </p>
<ul>
<li>在线程中隔离数据，并且不在多个线程中共享数据。唯一的例外是 ZeroMQ contexts，它是线程安全的</li>
<li>远离经典的并发机制，如互斥锁、临界区(critical sections)、信号量等。这是 ZeroMQ 应用程序中的反模式(anti-pattern)</li>
<li>在进程开始时创建 ZeroMQ context，并将其传递给希望通过 inproc 套接字连接的所有线程</li>
<li>使用 attached 线程在应用程序中创建结构，并使用 inproc 上的 PAIR 套接字将这些线程连接到它们的父线程。模式是:绑定父套接字，然后创建连接其套接字的子线程</li>
<li>线程之间的所有交互都以 ZeroMQ 消息的形式完成，可以或多或少地对其进行正式定义</li>
<li>不要在线程间共享 ZeroMQ 套接字。ZeroMQ 套接字不是线程安全的。从技术上讲，将套接字从一个线程迁移到另一个线程是可能的，但这需要技巧。在线程之间共享套接字的唯一合理的地方是需要在套接字上执行垃圾收集之类的魔法的语言绑定</li>
</ul>
<blockquote>
<hr>
<ul>
<li>Do not use or close sockets except in the thread that created them.</li>
</ul>
<hr>
</blockquote>
<p>ZeroMQ 使用 native OS threads，而不是虚拟的“绿色”线程。其优点是不需要学习任何新的线程 API，并且 ZeroMQ 线程可以清晰地映射到操作系统。可以使用标准的工具，比如英特尔的 ThreadChecker 来查看应用程序在做什么。缺点是本机线程 api 并不总是可移植的，并且如果有大量的线程(数千个)，某些操作系统将会受到压力。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multithreaded Hello World server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zhelpers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">worker_routine</span> <span class="params">(<span class="type">void</span> *context)</span> &#123;</span><br><span class="line">    <span class="comment">//  Socket to talk to dispatcher</span></span><br><span class="line">    <span class="type">void</span> *receiver = zmq_socket (context, ZMQ_REP);</span><br><span class="line">    zmq_connect (receiver, <span class="string">&quot;inproc://workers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *<span class="built_in">string</span> = s_recv (receiver);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Received request: [%s]\n&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">        <span class="built_in">free</span> (<span class="built_in">string</span>);</span><br><span class="line">        <span class="comment">//  Do some &#x27;work&#x27;</span></span><br><span class="line">        sleep (<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//  Send reply back to client</span></span><br><span class="line">        s_send (receiver, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    zmq_close (receiver);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *context = zmq_ctx_new ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Socket to talk to clients</span></span><br><span class="line">    <span class="type">void</span> *clients = zmq_socket (context, ZMQ_ROUTER);</span><br><span class="line">    zmq_bind (clients, <span class="string">&quot;tcp://*:5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Socket to talk to workers</span></span><br><span class="line">    <span class="type">void</span> *workers = zmq_socket (context, ZMQ_DEALER);</span><br><span class="line">    zmq_bind (workers, <span class="string">&quot;inproc://workers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Launch pool of worker threads</span></span><br><span class="line">    <span class="type">int</span> thread_nbr;</span><br><span class="line">    <span class="keyword">for</span> (thread_nbr = <span class="number">0</span>; thread_nbr &lt; <span class="number">5</span>; thread_nbr++) &#123;</span><br><span class="line">        <span class="type">pthread_t</span> worker;</span><br><span class="line">        pthread_create (&amp;worker, <span class="literal">NULL</span>, worker_routine, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  Connect work threads to client threads via a queue proxy</span></span><br><span class="line">    zmq_proxy (clients, workers, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  We never get here, but clean up anyhow</span></span><br><span class="line">    zmq_close (clients);</span><br><span class="line">    zmq_close (workers);</span><br><span class="line">    zmq_ctx_destroy (context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./images/multithreaded%20server.png" alt="Multithreaded Server"><br>消息流向：<code>REQ-ROUTER-queue-DEALER-REP</code></p>
<ul>
<li>服务端启动一组 worker 线程，每个线程创建一个 REP 套接字，并处理收到的请求。Worker 线程就像单线程服务。唯一的区别是使用 inproc 而不是 tcp，以及绑定-连接方向调换了</li>
<li>服务端创建 ROUTER 套接字用以和客户端通信，因此提供了一个 TCP 协议的外部接口</li>
<li>服务端创建 DEALER 套接字用以和 worker 通信，使用了 inproc</li>
<li>服务端启动连接两个套接字的代理。代理公平地从所有客户端提取传入请求，并将其分发给 worker 。它还将应答路由回它们的请求方</li>
</ul>
<p>注意：此例中创建线程使用的是 POSIX 提供的 pthreads 库，该方法在 windows 下不适用。后续介绍如何封装多线程编程的 API。  </p>
<h1 id="零拷贝※"><a href="#零拷贝※" class="headerlink" title="零拷贝※"></a>零拷贝※</h1><p>ZeroMQ 的消息 API 允许直接在应用程序缓冲区之间发送和接收消息，而无需复制数据。称之为 Zero-Copy，它可以提高某些应用程序的性能。  </p>
<p>在以高频率发送大块内存(数千字节)的特定情况下，应该考虑使用零拷贝。对于短消息或较低的消息速率，使用零拷贝反而将使代码更混乱和更复杂。  </p>
<p>使用零拷贝时，用 <code>zmq_msg_init_data()</code> 函数创建消息，其内容指向某个已经分配好的内存区域，然后将该消息传递给 <code>zmq_send()</code> 函数。创建消息时，还需提供一个用于释放消息内容的函数，ZeroMQ 会在消息发送完毕时调用。例如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_free</span> <span class="params">(<span class="type">void</span> *data, <span class="type">void</span> *hint)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span> (data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Send message from buffer, which we allocate and ZeroMQ will free for us</span></span><br><span class="line"><span class="type">zmq_msg_t</span> message;</span><br><span class="line">zmq_msg_init_data (&amp;message, buffer, <span class="number">1000</span>, my_free, <span class="literal">NULL</span>);</span><br><span class="line">zmq_msg_send (&amp;message, socket, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>注意，在发送消息后不要调用 <code>zmq_msg_close()</code> — libzmq 在实际完成发送消息时将自动执行此操作。  </p>
<p>在消息接收端无法使用零拷贝：ZeroMQ 会将收到的消息放入一块内存区域供用户读取，但不会直接将消息写入程序指定的内存区域。  </p>
<p>ZeroMQ 的 multipart 消息能够很好地支持零拷贝。在传统消息系统中，需要将不同缓存中的内容保存到同一个缓存中，然后才能发送。但 ZeroMQ 会将来自不同内存区域的内容作为消息的一个帧进行发送。而且在 ZeroMQ 内部，一条消息会作为一个整体进行收发，因而非常高效。  </p>
<h1 id="Pub-Sub-Message-Envelopes"><a href="#Pub-Sub-Message-Envelopes" class="headerlink" title="Pub-Sub Message Envelopes"></a>Pub-Sub Message Envelopes</h1><p>在 Pub-Sub 模式中，可以将 key 拆分为一个单独的消息帧，称之为信封(envelope)。如果想用 pub-sub envelopes，需要自行生成和设置。这是可选的，在之前的发布-订阅示例中，没有这样做。对于简单的情况，使用 pub-sub envelopes 需要做更多的工作，但是对于真正的情况，它更清晰，因为 key 和数据自然是分开的。<br><img src="/./images/pub-sub%20envelop.png" alt="pub-sub envelop">  </p>
<p>带发布者地址的 envelope：<br><img src="/./images/pub-sub%20envelop%20with%20sender%20address.png" alt="pub-sub envelop with sender address"></p>
<h1 id="High-Water-Marks-即-HWM"><a href="#High-Water-Marks-即-HWM" class="headerlink" title="High-Water Marks(即 HWM)"></a>High-Water Marks(即 HWM)</h1><p>当在进程之间快速地发送消息时，很快就会发现内存是一种宝贵的资源，而且很容易被填满。除非了解问题所在并采取预防措施，否则流程中某个地方的几秒钟延迟可能会变成导致服务器崩溃的积压。  </p>
<p>问题：假设进程 A 以高频率向正在处理它们的进程 B 发送消息。突然间，B 变得非常繁忙(垃圾收集、CPU 过载等等)，并且在短时间内无法处理消息。对于一些繁重的垃圾收集，可能需要几秒钟，如果有更严重的问题，可能需要更长的时间。进程 A 仍然试图疯狂发送消息会发生什么?有些会在 B 的网络缓冲区中。一些将位于以太网线本身。有些会在 A 的网络缓冲区中。剩下的会在 A 的内存中积累，和 A 后面的应用程序发送它们的速度一样快。如果不采取一些预防措施，A 很容易耗尽内存并崩溃。  </p>
<p>这是消息代理的一个一贯的经典问题。更糟糕的是，表面上看，这是 B 的错，而 B 通常是 A 无法控制的用户编写的应用程序。</p>
<p>解决方案：一是将问题向上游传递。A 从其他地方获取信息。告诉这个进程，“停止!”等等，这被称为<strong>流量控制</strong>。这听起来似乎有道理，但如果正在发送 Twitter 消息呢?你会告诉全世界不要再发推特了吗?  </p>
<p><strong>流量控制</strong>在某些情况下有效，但在其他情况下无效。传输层不能告诉应用层“停止”，就像地铁系统不能告诉一个大企业，“请你的员工再工作半个小时。我太忙了”。消息传递的答案是<strong>限制缓冲区的大小</strong>，然后当达到这些限制时，采取一些明智的行动。在某些情况下(但不包括地铁系统)，答案是扔掉信息。在其他情况下，最好的策略是等待。  </p>
<p><strong>ZeroMQ 使用 <code>HWM</code> 来定义其内部 pipes 的容量</strong>。每个出套接字或入套接字的连接都有自己的管道和用于发送和&#x2F;或接收的 HWM，具体取决于套接字类型。一些套接字(PUB, PUSH)只有发送缓冲区。有些(SUB, PULL, REQ, REP)只有接收缓冲区。一些(DEALER, ROUTER, PAIR)同时具有发送和接收缓冲区。  </p>
<p>在 ZeroMQ v2 中。缺省情况下，<code>HWM</code> 为无穷大。在 ZeroMQ v3.X 中，默认设置为 1000。  </p>
<p><strong>当套接字达到其 <code>HWM</code> 时，它将根据套接字类型阻塞或丢弃数据</strong>。PUB 和 ROUTER 套接字在达到 <code>HWM</code> 时将丢弃数据，而其他类型的套接字将阻塞。<strong>在 inproc 传输中，发送方和接收方共享相同的缓冲区，因此真正的 <code>HWM</code> 是双方设置的 <code>HWM</code> 的总和</strong>。  </p>
<p>最后，<code>HWM</code> 是不精确的；虽然默认情况下最多可以获得 1000 条消息，但由于 libzmq 实现队列的方式，实际缓冲区大小可能要小得多(只有一半)。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ZeroMQ/" rel="tag"># ZeroMQ</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/09/07/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/ZeroMQ/" rel="prev" title="ZeroMQ">
                  <i class="fa fa-angle-left"></i> ZeroMQ
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/09/07/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/ZeroMQ/ZeroMQ%20context/" rel="next" title="ctx_t">
                  ctx_t <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Damon</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">523k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">15:50</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
